# Основная информация

#### [git hub code](https://github.com/poituk/StickGame)

Используемый язык программирования: JavaScript

Библиотеки: react, bootstrap, react-toastify.

Папка со всеми игровыми компонентами src/componentsРеализованный функционал (дополнительный)

* Список правил в настройках и в меню
* Итоговое время игры
* Количество ходов за игру
* Время хода (для всех режимов) / таймер хода (для режимов на 2 игроков)
* Выбор нескольких палочек одним нажатием
* Проверка корректности хода / данных
* Всплывающие уведомления при ошибке
* Выбор имени для игроков
* В режиме против бота можно использовать 3 подсказки (посмотреть как бы походил компьютер)

# Стратегии ботов

## Режим "Стандартный", "Диапазонный" (standartBot.js)

    Режим "Стандартный" можно считать подрежимом "Диапазонный" поскольку отличие заключается в том, что в стандартном просто l = 1, поэтому можно рассматривать эти режимы как один.**dp[i]** = выигрышная (1) / проигрышная позиция (0).

Тогда все **dp[0 ... (l - 1)] = 0**, так как в этих позициях невозможно взять ни одну палку.

Для остальных же позиций если из dp[i] есть переход в в проигрышную позицию, то это позиция выигрышная, иначе проигрышная.

#### Итоговая формула:

Для i >= l:

    dp[i] = 1, если существует j ∈ [l, r] такой, что (i - j ≥ 0) и (dp[i - j] == 0)

    dp[i] = 0, иначе

Иначе:

    dp[i] = 0

Если у бота есть переход в проигрышную позицию то он туда переходит (в этом случае игрок уже не может выиграть), иначе он ищет позицию j у которой наименьшее количество переходов в проигрышные позиции (надежда на ошибку игрока).

#### Асимптотика O(n)

## Режим "Рядом", "Комбинированный" (inRowBot.js)

Опять же отличие между режимами не большое, их тоже можно рассматривать вместе.

Эти режимы очень похожи на задачу **"Lasker's nim"** [e-maxx.ru](http://e-maxx.ru/algo/sprague_grundy).

Но есть пару отличий влияющих на формулу.

1. Мы можем брать ограниченное количество палочек.
2. У нас одна операция. Деление одной кучки **n** на две кучки **n1** и **n2**, таких что **n1 + n2 = n - j**, где **j ∈ [l, r]**

### Тогда итоговая формула для подсчёта чисел гранди:

    g[n] = mex( ⋃ { g[n₁] ⊕ g[n₂] | j ∈ [l, r], n₁ + n₂ = n - j } )

Опять же все g[0 ... l - 1] = 0.

В итоге наш бот сначала разбивает поле на кучки (подряд идущие целые палочки). Затем считает числа **Гранди** для

**i ∈ [0, (количество палочек в максимальной кучке)]**. Далее находим **xor** получившихся кучек (чисел Гранди этих кучек). Если итоговой **Xor = 0**, тогда позиция проигрышная, в таком случае бот возьмёт минимальное количество палочек что может (затягиваем игру). Иначе пробуем разбить какую-то кучку на две кучки, чтобы после нашей операции **Xor** стал равен 0.

Пусть N - количество кучек, MX - максимальный размер кучки, D = r - l + 1.

#### Асимптотика O(MX * D * MX + N * D * MX)

### Стратегия по проще

На самом деле игрок, который ходит первый всегда может 100% выиграть (кроме одного случая), это можно заметить и по числам Гранди. Можно использовать симметричную стратегию для победы в этой игре. Сначала первым ходом мы делим поле на две части по середине так, чтобы образовались одинаковые кучки слева и справа. Теперь после каждого хода второго игрока мы будем брать симметрично центра такие же палочки с противоположной стороны. Рано или поздно при такой игре мы заберём последние. Однако если мы можем взять палочки только одним способом (k = 1, a = b), то эту стратегию можно будет реализовать, только если поле имеет такую же чётность с k или a, так как иначе первым ходом мы не сможем разделить поле на равные части.

## Режим "Особый" (specialBot.js)

В этом режиме уже нельзя считать числа Гранди в отдельности для каждой кучки. Так как у нас есть операция взять 3 подряд идущие палочки и операция взять 2 палочки откуда угодно. Мы теперь не можем рассматривать каждую кучку как отдельную игру и объединять их с помощью **xor**.

Будем действовать также как в первых двух режимах. **dp[field]** = выигрышная (1) / проигрышная позиция (0). Переходы согласно правилам берём 1, 2 откуда угодно, 3 только подряд. Не можем походить или не можем пойти в проигрышную **dp[field]** = 0. Можем перейти в проигрышную **dp[field]** = 1.

Тогда асимптотика переходов n для переходов с одной и тремя палочками, n² для  переходов с двумя палочками, где n размер поля.

Всего комбинаций field может быть $2 ^ k$ где k количество палочек на поле.

Получается что общая асимптотика порядка $2 ^ k * n^2$, что при размере поля в 50 слишком много. Поэтому бот работает корректно только для k <= 20 (на самом деле не до к <= 20, это ещё будет зависеть от пустых пространств между палочками), если не известна выигрышная или проигрышная, то алгоритм берёт палки случайно.
